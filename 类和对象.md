###类：具有相同特征和行为的食物的抽象集合
###对象：是类里面的具体的个例

###Demo1
```
import Foundation
//class ：类的关键字
//class后面的表示类名
//从类名的后面的{到结束的}之间的内容代表类的内部


class Person{
 //属性：swift有三种类型的属性：1、储存属性、2、计算属性、3、类属性（swift语言中的属性和其他语言的成员变量很类似）
 var name:String = ""

 //注意：储存属性必须赋初始值
 var age:Int = 20



 //如果某些属性初始化的时候不一定马上使用，并且很大很消耗资源，这样的属性可以用延迟储存属性修饰,用到的时候再去加载
 lazy var dog:Dog = Dog()

 //计算属性：不是用来储存属性值的，提供了get、set方法，通过重写set、get方法对属性做一些简单的运算。
 var english:Int = 0
 var math:Int = 0
 var chinese:Int = 0

 //注意：计算属性不能赋初始值、提供set、get方法；
 var sum:Int{
 get{
 return chinese+math+english
 }
 }

 //类属性：用class修饰；只能是计算属性，不能是储存属性；
 class var des: String {
 get{
 return "这是一个人"
 }
 }

 //行为-》方法
 func sleep(){
 print("这是一个人在睡觉")
 }
}

//dog类
class Dog{
 init() {
 print("这是一只狗")
 }
}


var p = Person() //p是person类的一个对象，（）表示一个默认的构造函数
p.name = "昔年"

print("\(p.name)")
p.sleep()

p.math = 100
p.english = 90
p.chinese = 90

print("总分为:\(p.sum)")
print("\(Person.des)")
```


###面向对象3打特性：继承、封装、多态
    继承
```
import Foundation
//继承：一个类可以从它的父类或者基类中直接拿过来属性或者方法去使用。
//父类：父类和子类是一对相对的概念，A是B的父类，B是A的子类

class Person{
 var name:String = ""
 //如果一个储存属性没有赋初始值，那么在每个init构造函数或者自定义的构造函数里面必须赋初始值
 var age:Int
 //一个对象创建完毕后都需要调用构造函数进行初始化，也就是oc的初始化
 //没有func关键字
 //没有返回值

 init() {
 print("这是一个人的构造方法")
 self.age = 0
 }

 init(age:Int,name:String) {
 self.age = age
 self.name = name
 }

 func sleep(){
 print("这是一个人在睡觉")
 }


 //析构函数:用来释放该对象的资源，类似oc的dealloc方法
 //swift也采用ARC机制

 deinit {
 print("人已经死亡")
 }
}

//子类重写父类的方法用override关键字
//一个类都会有init构造方法
//在子类重写父类的方法时必须使用override关键词，在方法体中要想调用父类方法，可以用super.方法名（）

class Man: Person {

 override init(){
 super.init()
 print("这是一个男人的构造方法")
 }

 override func sleep() {
 super.sleep()
 print("这是一个男人在睡觉")
 }
}

var man = Man()
print("\(man.name)")

man.name = "刘斌鹏"
print("\(man.name)")
man.sleep()

var p1 = Person(age:21, name:"昔年")
print("name---\(p1.name),age---\(p1.age)")

func f(){
 //p2对象只在该函数作用域内存在，调用完毕该对象销毁
 var p2 = Person()
}

print("***********")
f()
print("-----------")
```


###多态
    父类指针（引用）指向子类的对象